---
layout: post
title: LeetCode - Sort
categories: LeetCode
description: Here is description.
keywords: LeetCode, Sort, Quick Sort,Bucket Sort. 

---

# Sort

[TOC]



## 215\. Kth Largest Element in an Array (Medium)

[LeetCode](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)

Given an integer array `nums` and an integer `k`, return *the* `kth` *largest element in the array*.

Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.

Solution 1: **PriorityQueue**

```java
static public int findKthLargest(int[] nums, int k) {
    //Min Heap - Top K
    PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>();
    for(int num:nums){
        pQueue.add(num);
        if(pQueue.size()>k){
            pQueue.poll();
        }
    }
    return pQueue.peek();
}
```

Solution 2: **Quick Sort**

```java
static public int findKthLargest(int[] nums, int k) {
    k = nums.length - k;
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int j =  randomPartition(nums, l, h);
        if (j == k) {
            break;
        } else if (j < k) {
            l = j + 1;
        } else {
            h = j - 1;
        }
    }
    return nums[k];
}
//randomly - speed up - avoid O(n^2)
public static int randomPartition(int[] a, int l, int r) {
    Random random = new Random();
    int i = random.nextInt(r - l + 1) + l;
    swap(a, i, r);
    return partition(a, l, r);
}

static int partition(int[] nums, int left, int right){
    int i = left, j = right + 1;
    while (true) {
        while (nums[++i] < nums[left] && i < right) ;
        while (nums[--j] > nums[left] && j > left) ;
        if (i >= j) {
            break;
        }
        swap(nums, i, j);
    }
    swap(nums, left, j);
    return j;
}

static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr [i] =  arr[j];
    arr[j] = temp;
}
```

Solution 3:

This is solution from leetcode. Another way to implement quick sort in JAVA.

**Note:** This should also use 'random'.

```java
static public String findLongestWord(String s, List<String> dictionary) {
    String result = "";
    for(String dic:dictionary){
        if (result.length()>dic.length() || ((result.length()==dic.length())&&(result.compareTo(dic))<0)){
            continue; //skip - no need to compare
        }
        if (isSub(s,dic)){
            result = dic;
        }
    }
    return result;
}
static public boolean isSub(String s, String result){
    int i=0,j=0;
    while (i<s.length() && j<result.length()){
        if(s.charAt(i) == result.charAt(j)){
            j++;
        }
        i++;
    }
    return j==result.length();
}
```

## 347\. Top K Frequent Elements (Medium)

[LeetCode](https://leetcode.com/problems/top-k-frequent-elements/description/)

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

Solution 1: bucket sort

```java
static public int[] topKFrequent(int[] nums, int k) {
    //每个元素出现次数
    Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();
    for (int num : nums) {
        occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
    }

    // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数
    PriorityQueue<int[]> pQueue = new PriorityQueue<>(new Comparator<int[]>() {
        public int compare(int[] m, int[] n) {
            return m[1] - n[1]; //根据第二个元素的大小（即出现频率）排序
        }
    });

    /*
    另一种写法：
    PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()-b.getValue());

     */

    //队列里放所需要的
    for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {
        int num = entry.getKey(), count = entry.getValue();
        System.out.println("key = "+num+" value = "+count);
        if (pQueue.size() == k) { //队列人数满了
            //如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。
            // 如果堆顶更大，说明至少有 kk 个数字的出现次数比当前值大，故舍弃当前值；
            // 否则，就弹出堆顶，并将当前值插入堆中
            if (pQueue.peek()[1] < count) {
                pQueue.poll();
                pQueue.offer(new int[]{num, count});
            }

        }else {
            pQueue.offer(new int[]{num,count});
        }
    }

    int[] ans = new int[k];
    for (int i=0;i<k;i++){
        ans[i] = pQueue.poll()[0];
    }
    return ans;
}
```

Thanks to [cyc2018.xyz](http://www.cyc2018.xyz/)!

